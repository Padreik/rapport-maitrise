\chapter{Détection des mots-clés}
\label{chap:keywords}

Afin d'identifier les mots-clés pr\'esents dans le texte d'un \'etudiant et les comparer avec ceux fournis par l'enseignant, nous avons décidé d'utiliser la racine de chaque mot.
En utilisant la racine de chaque mot, nous pouvons trouver les mots-clés, peu importe leur accord ou le temps de verbe.
Deux techniques de recherche de racine d'un mot ont été retenues: la lemmatisation et la racination (\textit{stemming}).

Lors du choix de la technique utilisée, nous avons pris en considération les points suivants:

\begin{enumerate}
  \item Le but du projet n'étant pas de faire de l'analyse linguistique, une biblioth\`eque devra être utilisée si possible;
  \item La biblioth\`eque doit être écrite en PHP, langage utilisé par Moodle, afin de faciliter l'installation du module d'extension développé;
  \item La biblioth\`eque doit permettre de trouver la racine des mots en français, en anglais, et en plusieurs autres langues si possible, et ce afin de permettre l'utilisation du module d'extension à travers le monde.
\end{enumerate}

\section{La lemmatisation}

La lemmatisation consiste à trouver le lemme de chaque mot.
Le lemme est la forme canonique d'un mot, soit l'infinitif pour un verbe, le masculin singulier pour un adjectif, etc.
Par exemple, le lemme du verbe \og aimerait \fg{} est \og aimer \fg{}.

La  technique de lemmatisation utilise habituellement un dictionnaire qui associe toutes les conjugaisons possibles d'un mot à leur lemme.
Certaines biblioth\`eques vont même considérer le contexte afin de trouver le bon lemme.

Les biblioth\`eques de lemmatisation écrites en PHP sont rares.
Lors de nos recherches, aucune de ces biblioth\`eques ne supportait le français et l'anglais.

\section{La racination}

La racination consiste à trouver la racine (parfois appelé radical, ou \emph{stem} en anglais) de chaque mot.
La racine est trouvée par un algorithme en enlevant la fin du mot.
Par exemple, la racine de \og aimerait \fg{} est \og aim \fg{}.
Cette technique ignore la plupart des exceptions.

La racination est moins précise que la lemmatisation.
Par exemple, la racine de \og courons \fg{} est la même que la racine de \og couronnement \fg{}, soit \og couron \fg{}.
La lemmatisation ne fera pas la même erreur et trouvera les lemmes \og courir \fg{} et \og couronne \fg{}.
En contrepartie, la recherche de la racine sera plus rapide avec un algorithme de racination qu'une recherche dans un dictionnaire de lemmes.

Il existe quelques biblioth\`eques de racination en PHP.
Une d'elles est \href{https://github.com/wamania/php-stemmer}{\texttt{php-stemmer}} qui fait la racination en français, en anglais, et dans dix autres langues.
Les algorithmes utilisés par \texttt{php-stemmer} sont basés sur les algorithmes écrits en Snowball, un langage développé pour la racination.
L'algorithme de racination en anglais ainsi que Snowball ont été développés par Martin Porter.

\GT{Il faudrait indiquer une r\'ef\'erence ci-haut. Celle indiqu\'ee
par href n'est pas visible on dirait dans le PDF.}

Comme nous avons trouvé une biblioth\`eque de racination qui satisfait tous les critères et aucune biblioth\`eque de lemmatisation n'en fait autant, ce projet va utiliser \texttt{php-stemmer} pour la découverte de mots-clés.

\section{Snowball}

Snowball est un petit langage de traitement de texte pour la racination de texte.
Une application Snowball peut être compilée en C ou en Java.
Le site web de Snowball donne l'algorithme de racination pour plusieurs langues: anglais, français, espagnol, allemand, russe, etc.
L'algorithme pour la langue anglaise se base sur l'algorithme de Porter.
%
\GT{Pr\'ef\'erable si tu pouvais donner une r\'ef\'erence, avec $\backslash$cite\{...\}, pour cet algorithme.}
%
L'auteur a créé une deuxième version en se basant sur des algorithmes pour les langues latines.
L'origine des algorithmes pour les langues latines, incluant la langue française, n'est pas donnée, mais semble venir aussi de Porter et de contributeurs.

La biblioth\`eque \texttt{php-stemmer} a été écrite en PHP par Wamania en se basant sur les algorithmes écrits en Snowball.
Le reste de cette section tente d'expliquer la logique derrière l'algorithme de Snowball pour le français.
L'algorithme est séparé en six étapes, en plus d'une étape de préparation et d'une étape finale.

\begin{itemize}

\item{Préparation}

Premièrement, le mot est transformé en minuscule par \texttt{php-stemmer}.
Les lettres u et i précédées et suivies par une voyelle, les lettres y précédées ou suivies par une voyelle ainsi que les u précédées de q sont mises en majuscules.
Les lettres en majuscules sont considérées en tant que consonnes dans l'algorithme.
Par exemple, dans le mot \og joUer \fg{}, le U ne sera pas considéré comme une minuscule.
Pour déterminer si une lettre est une voyelle, l'algorithme utilise la liste de lettres suivante~: a, e, i, o, u, y, â, à, ë, é, ê, è, ï, î, ô, û et ù.
Donc une voyelle en majuscule ne fait pas partie de cette liste.

Ensuite, il faut trouver trois sections dans le mot: RV (\emph{right vowel}), R1 (\emph{right 1}) et R2 (\emph{right 2}).
Dans les exemples qui suivent, les lettres soulignées indiquent les lettres faisant partie du groupe.

\begin{description}
  \item[RV]
  
  Si le mot débute par deux voyelles, RV débute après la troisième lettre (oub\underline{lier}).
  Si le mot commence par \og par, col ou tap \fg{}, RV définit les lettres qui suivent (col\underline{onne}).
  Dans les autres cas, RV débute après la première voyelle excluant la première lettre (bo\underline{njour}, algo\underline{rithme}).
  Si aucune de ses règles ne s'applique, RV est vide (un sigle comme IBN).
  RV n'existe pas dans l'algorithme pour la langue anglaise.
  
  \item[R1]
  
  R1 débute après la première consonne précédée d'une voyelle (aim\underline{er}, tap\underline{is}).
  R1 est vide s'il n'y a pas de telle consonne.
  
  \item[R2]
  
  R2 débute après la première consonne précédée d'une voyelle dans R1 (fameus\underline{ement}).
  R2 est vide s'il n'y a pas de telle consonne.
\end{description}

RV peut contenir R1 et inversement.
Les lettres qui ne sont ni dans R1, ni dans RV ne seront pas touchées sauf pour quelques exceptions.

\item{Étape 1: Suffixes standards}

Cette étape sert à trouver la racine des mots, adjectifs, adverbes, etc.

Il faut trouver le suffixe le plus long parmi une liste donnée et faire l'action correspondante.
Voici des exemples de la liste qui compte 43 suffixes et 24 règles~: 

\begin{itemize}
  \item \textbf{ance iqUe isme able ...}: Supprimer si dans R2;
  \item \textbf{atrice ateur ation ...}: Supprimer si dans R2. Si précédé de \textbf{ic}, supprimer si dans R2, sinon remplacer par \textbf{iqU};
  \item \textbf{logie logies}: Remplacer par \textbf{log} si dans R2;
  \item \textbf{eaux}: Remplacer par \textbf{eau};
  \item \textbf{aux}: Remplacer par \textbf{al} si dans R1;
  \item \textbf{amment}: Remplacer par \textbf{ant} si dans RV;
  \item \textbf{emment}: Remplacer par \textbf{ent} si dans RV;
  \item \textbf{ment ments}: Supprimer si dans RV.
\end{itemize}

\item{Étape 2: Suffixes de verbes}

Cette étape trouve la racine d'un verbe.
On cherche et enlève les suffixes standards.

Il faut faire cette étape seulement si l'étape 1 n'a rien changé ou si un des suffixes suivants a été trouvé: amment, emment, ment et ments.

\begin{itemize}
\item{Étape 2a: Suffixes débutant par i}

Trouver le suffixe le plus long parmi la liste ci-dessous.
S'il est précédé d'une consonne et que le tout est dans RV, supprimer le suffixe excluant la consonne supplémentaire.

îmes, ît, îtes, i, ie, ies, ir, ira, irai, iraIent etc.

\item{Étape 2b: Autres suffixes de verbes}

Trouver le suffixe le plus long parmi les trois listes ci-dessous.
Les listes sont non-exaustives afin d'alléger le texte.

\begin{description}
  \item[ions]
  
  Supprimer si dans RV et R2;
  
  \item[é ée ées és èrent er era erai eraIent ...]
  
  Supprimer si dans RV;
  
  \item[âmes ât âtes a ai aIent ...]
  
  Supprimer si dans RV. Si la lettre e précède le suffixe et qu'elle se trouve aussi dans RV, la supprimer.
\end{description}


\end{itemize}

\item{Étape 3: Dernière lettre}

Si les étapes 1 ou 2 ont modifié le mot, faire cette étape, sinon passer à l'étape 4.

Si la dernière lettre est un Y, la remplacer par i.
Si c'est un ç, la remplacer par c.

\item{Étape 4: Résidue du suffixe}

Il faut faire cette étape seulement si les étapes 1 à 3 n'ont pas modifié le mot.
Cette étape sert à enlever le pluriel et le féminin des mots proches de leurs racines.

Si un mot se termine par \textbf{s} et n'est pas précédé de \textbf{a, i, o, u, è ou s}, supprimer ce s final.

Si un mot se termine par \textbf{ion}, que cette finale se trouve dans RV et dans R2 et qu'elle est précédée de la lettre \textbf{s ou t} (cette dernière doit se trouver dans RV), supprimer la finale \textbf{ion}.

Si un mot se termine par \textbf{ier, ière, Ier ou Ière} et que cette finale se trouve dans RV, remplacer cette dernière par \textbf{i}.

Si un mot se termine par \textbf{e} et que cette lettre ce trouve dans RV, la supprimer.

Si un mot se termine par \textbf{ë}, que cette lettre se trouve dans RV et qu'elle est précédée de \textbf{qu}, la supprimer.

\item{Étape 5: Dédoubler la lettre finale}

Les suppressions et remplacements des étapes précédentes peuvent laisser une faute dans la racine du mot.
Cette étape sert à enlever les lettres doubles de certaines finales de mots.

Si un mot se termine par \textbf{enn, onn, ett, ell ou eill}, supprimer la dernière lettre.

\item{Étape 6: Accent final}

Cette étape aussi sert \`a nettoyer la racine du mot.

Si un mot se termine par la lettre \textbf{è ou é} suivi d'une ou plusieurs consonnes, enlever l'accent de ce \textbf{e}.

\item{Finalisation}

Finalement, on enlève les majuscules sur les voyelles ajoutées durant l'étape de préparation.

\end{itemize}

Au final, on obtient la racine du mot.
Lors de la comparaison de texte, il peut y avoir quelques problèmes.
Par exemple les mots \og acceptables \fg{} et \og accepté \fg{} ont la même racine: \og accept \fg{}.
Par contre, le sens des deux mots est différent.
