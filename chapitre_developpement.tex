\chapter{Développement du module d'extension \og qtype\_essayhelper \fg{} }

Le développement d'un module d'extension Moodle n'est pas intuitif.
La documentation n'est pas toujours complète et l'interaction dans le code entre les types de modules d'extensions \og Rapport de questionnaire \fg{}, \og Type de question \fg{} et \og Comportement de question \fg{} n'est pas toujours claire.
Dans le développement de ce module d'extension, le code du module d'extension \og qtype\_essay \fg{} a été utilisé comme documentation.
En prenant ce module d'extension comme base, il a été facile de construire ce qui était désiré.

Les commentaires de copyrights ont été ajustés comme illustré à l'exemple de code~\ref{code:commentaire}

\begin{lstfloat}
\begin{lstlisting}[frame=l]
/**
 * Essay for correction helper question definition class.
 *
 * @package    qtype
 * @subpackage essayhelper
 * @copyright  2017 Philippe Girard
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 *
 * Inspired by:
 * @package    qtype
 * @subpackage essay
 * @copyright  2009 The Open University
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
\end{lstlisting}
\caption{Exemple des commentaires dans les fichiers du module d\'extension.}
\label{code:commentaire}
\end{lstfloat}

\section{Fonctionnalités}

Plusieurs fonctionnalités du module d'extension \og qtype\_essay \fg{} ont été enlevées:

\begin{description}
  \item[Éditeur de texte WYSIWIG]
  
  Il permet de modifier l'apparence du texte facilement.
  Ça permet, entre autres, de surligner, de souligner, de mettre en gras, de mettre en italique et plus encore.
  Comme on ne peut pas enlever des options WYSIWIG pour un seul module d'extension, ça devient complexe de trouver une mise en forme qui permettra de mettre en évidence les mots clés, car un étudiant pourrait, par erreur, reproduire la même mise en forme.
  
  \item[Remise de fichier]
  
  Il est possible d'écrire directement dans la zone de texte ou de remettre un document texte (configurable par l'enseignant).
  Comme le module d'extension n'aidera pas à corriger les textes remis par fichier, cette option a été enlevée.
\end{description}

Plusieurs fonctionnalités sont restées dans le nouveau module d'extension:

\begin{description}
  \item[Rétroaction générale]
  
  Permet de laisser un commentaire à l'étudiant une fois que la correction est disponible.
  Par exemple, l'enseignant pourrait laisser des explications pour les erreurs courantes.
  
  \item[Modèle de réponse]
  
  Prérempli la zone de texte de l'étudiant avec le texte donné.
  Par exemple, un en-tête de fonction pour une question de programmation ou la liste des mots à définir.
  
  \item[Information de l'évaluateur]
  
  Affiche un texte pour le correcteur seulement.
  Utile pour voir facilement le barème de correction ou donner des instructions au correcteur.
  Est affiché sous la réponse de l'étudiant lors de la correction.
\end{description}

Finalement, les fonctionnalités suivantes ont été ajoutées:

\begin{description}
  \item[Mots-clés]
  
  Les mots-clés seront mis en évidence dans la réponse de l'étudiant lors de la correction manuelle

  \item[Réponse officielle de l'enseignant]
  
  Affiche ce texte à droite de la réponse de l'étudiant lors de la correction.
  Les mots-clés seront mis en évidence aussi dans ce texte.
\end{description}

\section{Détection des mots clés}

Un module d'extension Moodle est programmée avec le langage PHP.
Le module d'extension développé devrait pouvoir fonctionner avec plusieurs langues afin de pouvoir le déployer sur le répertoire de modules d'extensions Moodle.

Les mots-clés peuvent avoir des différences d'accord ou de conjugaison dans le texte de l'étudiant lorsqu'on les compare avec les mots-clés fournis par l'enseignant.
Il faut donc ramener les mots à leur forme la plus simple.
Deux techniques existent, la lemmatisation et la racination (\og stemming \fg{} en anglais).

\begin{description}
  \item[Lemmatisation]
  
  La lemmatisation met le mot dans sa forme la plus simple (singulier, masculin, infinitif, etc.).
  Par exemple le verbe \og aimerait \fg{} sera transformé en \og aimer \fg{}.
  
  \item[Racination]
  
  La racination enlève la fin du mot afin d'en conserver seulement la racine.
  Par exemple le verbe \og aimerait \fg{} sera transformé en \og aim \fg{}.
\end{description}

La lemmatisation est une solution plus exacte que la racination, mais beaucoup plus complexe.
Mes recherches n'ont identifié aucune librairie PHP de lemmatisation fonctionnant avec plusieurs langues.
Par contre il existe une librairie de racination libre de droits appelés php-stemmer \cite{phpstemmer}.
Elle est sous \href{https://raw.githubusercontent.com/wamania/php-stemmer/master/LICENSE}{licence MIT} et utilise un algorithme développé par Martin Porter écrite dans un langage appelé Snowball \cite{snowball}.
php-stemmer permet de faire la racination des mots en français, anglais, espagnol, allemand, italien, russe et plusieurs autres.
Le détail de l'algorithme Snowball est détaillé dans la section suivante.

Pour trouver la racine de tous les mots du texte, les caractères non alphanumériques sont remplacés par des espaces et le texte est découpé par les caractères d'espacements (espace, saut de ligne, tabulation, etc.).

\begin{lstfloat}
\begin{lstlisting}[frame=l]
$words = preg_split('/(\s|\')/', preg_replace('/[^[:alnum:][:space:]]/u', ' ', $sentence));
\end{lstlisting}
\caption{Isoler les mots du texte.}
\label{code:commentaire}
\end{lstfloat}

Ensuite, chaque mot est associé avec sa racine trouvée avec l'algorithme Snowball.
Chaque mot-clé a, préalablement, aussi été réduit à leur racine avec l'algorithme Snowball.

\begin{lstfloat}
\begin{lstlisting}[frame=l]
foreach ($words as $word) {
	if ($word) {
		if (Wamania\Snowball\Utf8::check($word)) {
			$stem = $stemmer->stem($word);
			if (isset($stems[$stem])) {
				if (!in_array($word, $stems[$stem])) {
					$stems[$stem][] = $word;
				}
			} else {
				$stems[$stem] = array($word);
			}
		} else {
			$stems[] = $word;
		}
	}
}
\end{lstlisting}
\caption{Racination des mots avec Snowball.}
\label{code:racinationsnowball}
\end{lstfloat}

Finalement les mots-clés trouvés dans le texte sont mis en évidence.

\begin{lstfloat}
\begin{lstlisting}[frame=l]
$usedKeywords = array_intersect(array_keys($stems), $keywords);

foreach ($usedKeywords as $keyword) {
	$words = $answerWords[$keyword];
	foreach ($words as $word) {
		$studentAnswer = str_replace($word, '<b><u>' . $word . '</u></b>', $studentAnswer);
	}
}
\end{lstlisting}
\caption{Mise en évidence des mots-clés trouvés.}
\label{code:commentaire}
\end{lstfloat}

\section{Snowball}

Snowball est un petit langage de traitement de texte pour la racination de texte.
Une application Snowball peut être compilée en C ou en Java.
Le site web de Snowball donne l'algorithme de racination pour plusieurs langues: anglais, français, espagnol, allemand, russe, etc.
L'algorithme pour la langue anglaise se base sur l'algorithme de Porter.
L'auteur a créé une deuxième version en se basant sur les algorithmes des langues latines.
L'origine des algorithmes donnés pour les langues latines, ce qui inclut la langue française, n'est pas donnée, mais semble venir aussi de Porter avec l'aide de contributeurs.
La libraire PHP utilisée a été écrite en PHP par Wamania en se basant sur les algorithmes écrits en Snowball.
Le reste de cette section tente d'expliquer la logique derrière l'algorithme de Snowball pour le français.
L'algorithme est séparé en six étapes en plus d'une étape de préparation et d'une étape finale.

\subsection*{Préparation}

Premièrement, le mot est transformé en minuscule par php-stemmer.
Les lettres u et i précédées et suivies par une voyelle, les lettres y précédées ou suivies par une voyelle ainsi que les u précédées de q sont mises en majuscules.
Les lettres en majuscules sont considérées en tant que consonnes dans l'algorithme.
Par exemple, dans le mot \og joUer \fg{}, le U ne sera pas considéré comme une minuscule.
Pour déterminer si une lettre est une voyelle, l'algorithme utilise une liste de lettres (a, e, i, o, u, y, â, à, ë, é, ê, è, ï, î, ô, û et ù).
Donc une voyelle en majuscule ne fera pas partie de la liste.

Ensuite il faut trouver trois sections dans le mot: RV (right vowel), R1 (right 1) et R2 (right 2).
Dans les exemples qui suivent, les lettres soulignées indiquent les lettres faisant partie du groupe.

\begin{description}
  \item[RV]
  
  Si le mot débute par deux voyelles, RV débute après la troisième lettre (oub\underline{lier}).
  Si le mot commence par \og par, col ou tap \fg{}, RV définit les lettres qui suivent (col\underline{onne}).
  Dans les autres cas, RV débute après la première voyelle excluant la première lettre (bo\underline{njour}, algo\underline{rithme}).
  Si aucune de ses règles ne s'applique, RV est vide (un sigle comme IBN).
  RV n'existe pas dans l'algorithme de la langue anglaise.
  
  \item[R1]
  
  R1 débute après la première consonne précédée d'une voyelle (aim\underline{er}, tap\underline{is}).
  R1 est vide s'il n'y a pas de telle consonne.
  
  \item[R2]
  
  R2 débute après la première consonne précédée d'une voyelle dans R1 (fameus\underline{ement}).
  R2 est vide s'il n'y a pas de telle consonne.
\end{description}

RV peut contenir R1 et inversement.
Les lettres qui ne sont pas dans R1 ni dans RV ne seront pas touchées sauf pour quelques exceptions.

\subsection*{Étape 1: Suffixes standards}

Cette étape sert à trouver la racine des mots, adjectifs, adverbes, etc.

Trouver le suffixe le plus long parmi une liste donnée et faire l'action correspondante.
Voici des exemples de la liste qui compte 43 suffixes et 24 règles.

\begin{itemize}
  \item \textbf{ance iqUe isme able ...}: Supprimer si dans R2;
  \item \textbf{atrice ateur ation ...}: Supprimer si dans R2. Si précédé de \textbf{ic}, supprimer si dans R2, sinon remplacer par \textbf{iqU};
  \item \textbf{logie logies}: Remplacer par \textbf{log} si dans R2;
  \item \textbf{eaux}: Remplacer par \textbf{eau};
  \item \textbf{aux}: Remplacer par \textbf{al} si dans R1;
  \item \textbf{amment}: Remplacer par \textbf{ant} si dans RV;
  \item \textbf{emment}: Remplacer par \textbf{ent} si dans RV;
  \item \textbf{ment ments}: Supprimer si dans RV.
\end{itemize}

\subsection*{Étape 2: Suffixes de verbes}

Cette étape trouve la racine d'un verbe.
On cherche et enlève les suffixes standards.

Faire cette étape seulement si l'étape 1 n'a rien changé ou si un des suffixes suivants a été trouvé: amment, emment, ment et ments.

\subsubsection*{Étape 2a: Suffixes débutant par i}

Trouver le suffixe le plus long parmi la liste ci-dessous.
S'il est précédé d'une consonne et que le tout est dans RV, supprimer le suffixe excluant la consonne supplémentaire.

îmes, ît, îtes, i, ie, ies, ir, ira, irai, iraIent etc.

\subsubsection*{Étape 2b: Autres suffixes de verbes}

Trouver le suffixe le plus long parmi les trois listes ci-dessous.
Les listes sont non-exaustives afin d'alléger le texte.

\begin{description}
  \item[ions]
  
  Supprimer si dans RV et R2;
  
  \item[é ée ées és èrent er era erai eraIent ...]
  
  Supprimer si dans RV;
  
  \item[âmes ât âtes a ai aIent ...]
  
  Supprimer si dans RV. Si la lettre e précède le suffixe et qu'elle se trouve aussi dans RV, la supprimer.
\end{description}

\subsection*{Étape 3: Dernière lettre}

Si les étapes 1 ou 2 ont modifié le mot, faire cette étape, sinon passer à l'étape 4.

Si la dernière lettre est un Y, la remplacer par i.
Si c'est un ç, la remplacer par c.

\subsection*{Étape 4: Résidue du suffixe}

Faire cette étape seulement si les étapes 1 à 3 n'ont pas modifié le mot.
Cette étape sert à enlever le pluriel et le féminin des mots proches de leurs racines.

Si un mot se termine par \textbf{s} et n'est pas précédé de \textbf{a, i, o, u, è ou s}, supprimer ce s final.

Si un mot se termine par \textbf{ion}, que cette finale se trouve dans RV et dans R2 et qu'elle est précédée de la lettre \textbf{s ou t} (cette dernière doit se trouver dans RV), supprimer la finale \textbf{ion}.

Si un mot se termine par \textbf{ier, ière, Ier ou Ière} et que cette finale se trouve dans RV, remplacer cette dernière par \textbf{i}.

Si un mot se termine par \textbf{e} et que cette lettre ce trouve dans RV, la supprimer.

Si un mot se termine par \textbf{ë}, que cette lettre se trouve dans RV et qu'elle est précédée de \textbf{qu}, la supprimer.

\subsection*{Étape 5: Dédoubler la lettre finale}

Les suppressions et remplacements des étapes précédentes peuvent laisser une faute dans la racine du mot.
Cette étape sert à enlever les lettres doubles de certaines finales de mots.

Si un mot se termine par \textbf{enn, onn, ett, ell ou eill}, supprimer la dernière lettre.

\subsection*{Étape 6: Accent final}

Cette étape aussi sert a nettoyer la racine du mot.

Si un mot se termine par la lettre \textbf{è ou é} suivit d'une ou de plusieurs consonnes, enlever l'accent de ce \textbf{e}.

\subsection*{Finalisation}

Finalement, on enlève les majuscules sur les voyelles ajoutées durant l'étape de préparation.

Au final, on obtient la racine du mot.
Lors de la comparaison de texte, il peut y avoir quelques problèmes.
Par exemple les mots \og acceptables \fg{} et \og accepté \fg{} ont la même racine: \og accept \fg{}.
Par contre le sens des 2 mots est différent.

\section{Tests}

Moodle offre deux types de tests: des tests d'acceptation et des tests unitaires.

\subsection{Tests d'acceptation}

Les tests d'acceptation sont exécutés à l'aide de Behat, un \og framwork \fg{} PHP d'automatisation de tests qui se base sur le \og \textit{Behavior Driven Development} (BDD) \fg{}.
Les tests sont écrits en anglais, compréhensibles par tous.
Chaque instruction et vérification doit être, préalablement, configurée en PHP.

Un serveur ou une application Selenium exécutera les tests directement dans l'interface d'un navigateur Web.

\begin{lstfloat}
\begin{lstlisting}[frame=l]
@qtype @qtype_essay
Feature: Test creating an Essay question
  As a teacher
  In order to test my students
  I need to be able to create an Essay question

  Background:
    Given the following "users" exist:
      | username | firstname | lastname | email               |
      | teacher1 | T1        | Teacher1 | teacher1@moodle.com |
    And the following "courses" exist:
      | fullname | shortname | category |
      | Course 1 | C1        | 0        |
    And the following "course enrolments" exist:
      | user     | course | role           |
      | teacher1 | C1     | editingteacher |
    And I log in as "teacher1"
    And I follow "Course 1"
    And I navigate to "Question bank" node in "Course administration"

  Scenario: Create an Essay question with Response format set to 'HTML editor'
    When I add a "Essay" question filling the form with:
      | Question name            | essay-001                      |
      | Question text            | Write an essay with 500 words. |
      | General feedback         | This is general feedback       |
      | Response format          | HTML editor                    |
    Then I should see "essay-001"
\end{lstlisting}
\caption{Test d'acceptation du module d\'extension \og qtype\_essay \fg{}.}
\label{code:commentaire}
\end{lstfloat}

\subsection{Tests unitaires}

Les tests unitaires sont exécutés avec PHP-Unit.

