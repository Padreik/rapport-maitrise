\chapter{Développement}

Le développement d'une extension Moodle n'est pas intuitif.
La documentation n'est pas toujours complète et l'interaction dans le code entre les types d'extensions rapport de questionnaire, type de question et comportement de question n'est pas toujours claire.
Dans le développement de cette extension, le code de l'extension \og qtype\_essay \fg{} a été utilisé comme documentation.
En prenant cette extension comme base, il a été facile de construire ce qui était désiré.

Les commentaires de copyrights ont été ajustés comme suit:

\begin{lstlisting}[frame=l]
/**
 * Essay for correction helper question definition class.
 *
 * @package    qtype
 * @subpackage essayhelper
 * @copyright  2017 Philippe Girard
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 *
 * Inspired by:
 * @package    qtype
 * @subpackage essay
 * @copyright  2009 The Open University
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
\end{lstlisting}

\section{Fonctionnalités}

Plusieurs fonctionnalités de l'extension \og qtype\_essay \fg{} ont été enlevées:

\begin{description}
  \item[Éditeur de texte WYSIWIG]
  
  Il permet de modifier l'apparence du texte facilement.
  Ça permet, entre autres, de surligner, de souligner, de mettre en gras, de mettre en italique et plus encore.
  Comme on ne peut pas enlever des options WYSIWIG pour une seule extension, ça devient complexe de trouver une mise en forme qui permettra de mettre de l'emphase sur les mots clés, car un étudiant pourrait, par erreur, reproduire la même mise en forme.
  
  \item[Remise de fichier]
  
  Il est possible d'écrire directement dans la zone de texte ou de remettre un document texte (configurable par l'enseignant).
  Comme l'extension n'aidera pas à corriger les textes remis par fichier, cette option a été enlevée.
\end{description}

Plusieurs fonctionnalités sont restées dans la nouvelle extension:

\begin{description}
  \item[Rétroaction générale]
  
  Permets de laisser un commentaire à l'étudiant une fois que la correction est disponible.
  Par exemple, il pourrait laisser la réponse officielle selon les notes de cours ou des explications pour les erreurs courantes.
  
  \item[Modèle de réponse]
  
  Préremplis la zone de texte de l'étudiant avec le texte donné.
  Par exemple, un en-tête de fonction pour une question de programmation ou la liste des mots à définir.
  
  \item[Information de l'évaluateur]
  
  Affiche un texte pour le correcteur seulement.
  Utile pour voir facilement le barème de correction ou donner des instructions au correcteur.
  Est affiché sous la réponse de l'étudiant lors de la correction.
\end{description}

Finalement, les fonctionnalités suivantes ont été ajoutées:

\begin{description}
  \item[Mots-clés]
  
  Les mots-clés seront mis en évidence dans la réponse de l'étudiant lors de la correction manuelle

  \item[Réponse officielle de l'enseignant]
  
  Affiche ce texte à droite de la réponse de l'étudiant lors de la correction.
  Les mots-clés seront mis en évidence aussi dans ce texte.
\end{description}

\section{Détection des mots clés}

Une extension Moodle est programmée avec le langage PHP.
L'extension développée devrait pouvoir fonctionner avec plusieurs langues afin de pouvoir la déployer sur le répertoire d'extension Moodle.

Les mots-clés peuvent avoir des différences d'accords ou de conjugaison dans le texte de l'étudiant lorsqu'on les compare avec les mots-clés donnés par l'enseignant.
Il faut donc ramener les mots à leur forme la plus simple.
Deux techniques existent, la lemmatisation et la racination (stemming en anglais).

\begin{description}
  \item[Lemmatisation]
  
  La lemmatisation remet le mot à sa forme la plus simple (singulier, masculin, infinitif, etc.).
  Par exemple le verbe \og aimerait \fg{} sera remis à \og aimer \fg{}.
  
  \item[Racination]
  
  La racination enlève la fin du mot afin d'en conserver seulement la racine.
  Par exemple le verbe \og aimerait \fg{} sera remis à \og aim \fg{}.
\end{description}

La lemmatisation est une solution plus exacte que la racination, mais beaucoup plus complexe.
Mes recherches n'ont sorti aucune librairie PHP de lemmatisation fonctionnant avec plusieurs langues.
Par contre il existe une librairie de racination libre de droits appelés php-stemmer \cite{phpstemmer}.
Elle est sous \href{https://raw.githubusercontent.com/wamania/php-stemmer/master/LICENSE}{licence MIT} et utilise un algorithme développé par Dr Martin Porter écrite dans un langage appelé Snowball \cite{snowball}.
php-stemmer permet de faire la racination des mots en français, anglais, espagnol, allemand, italien, russe et plusieurs autres.
Le détail de l'algorithme Snowball est détaillé dans la section suivante.

Pour trouver la racine de tous les mots du texte, tous les caractères non alphanumériques sont remplacés par des espaces et le texte est découpé par les caractères d'espacements (espace, saut de ligne, tabulation, etc.).

\begin{lstlisting}[frame=l]
$words = preg_split('/(\s|\')/', preg_replace('/[^[:alnum:][:space:]]/u', ' ', $sentence));
\end{lstlisting}

Ensuite, chaque mot est associé avec sa racine trouvée avec l'algorithme Snowball.
Chaque mot-clé a, préalablement, aussi été réduit à leur racine avec l'algorithme Snowball.

\begin{lstlisting}[frame=l]
foreach ($words as $word) {
	if ($word) {
		if (Wamania\Snowball\Utf8::check($word)) {
			$stem = $stemmer->stem($word);
			if (isset($stems[$stem])) {
				if (!in_array($word, $stems[$stem])) {
					$stems[$stem][] = $word;
				}
			} else {
				$stems[$stem] = array($word);
			}
		} else {
			$stems[] = $word;
		}
	}
}
\end{lstlisting}

Finalement les mots-clés trouvés dans le texte sont mis en évidences.

\begin{lstlisting}[frame=l]
$usedKeywords = array_intersect(array_keys($stems), $keywords);

foreach ($usedKeywords as $keyword) {
	$words = $answerWords[$keyword];
	foreach ($words as $word) {
		$studentAnswer = str_replace($word, '<b><u>' . $word . '</u></b>', $studentAnswer);
	}
}
\end{lstlisting}

\section{Snowball}

Snowball est un petit langage de traitement de texte pour la racination de texte.
Une application Snowball peut être compilée en C ou en Java.
Le site web de Snowball donne l'algorithme de racination pour plusieurs langues: anglais, français, espagnol, allemand, russe, etc.
L'algorithme pour la langue anglaise se base sur l'algorithme de Porter.
L'auteur a créé une deuxième version en se basant sur les algorithmes des langues latines.
L'origine des algorithmes donnés pour les langues latines, ce qui inclut la langue française, n'est pas donnée, mais semble venir aussi de Porter avec l'aide de contributeurs.
La libraire PHP utilisé a été écrite en PHP par Wamania en se basant sur les algorithmes écrits en Snowball.
Le reste de cette section tentera d'expliquer la logique derrière l'algorithme de Snowball pour le français.
L'algorithme est séparé en 6 étapes en plus d'une étape de préparation et d'une étape finale.

\subsection*{Préparation}

Premièrement, le mot est transformé en minuscule par php-stemmer.
Les lettres u et i précédés et suivis par une voyelle, les lettres y précédé ou suivis par une voyelle ainsi que les u précédés de q sont mis en majuscules.
Les lettres en majuscules sont considérées en tant que consonnes dans l'algorithme.
Par exemple, le mot \og joUer \fg{}, le U ne sera pas considéré comme une minuscule.
Pour déterminer si une lettre est une voyelle, l'algorithme utilise une liste de lettre (a, e, i, o, u, y, â, à, ë, é, ê, è, ï, î, ô, û et ù).
Donc une voyelle en majuscule ne sortira pas de la liste.

Ensuite il faut trouver 3 sections dans le mot: RV (right vowel), R1 (right 1) et R2 (right 2).
Dans les exemples qui suivent, les lettres soulignées présenteront les lettres faisant partie du groupe.

\begin{description}
  \item[RV]
  
  Si le mot débute par deux voyelles, RV débute après la troisième lettre (oub\underline{lier}).
  Si le mot commence par \og par, col ou tap \fg{}, RV définit les lettres qui suivent (col\underline{onne}).
  Dans les autres cas RV débute après la première voyelle excluant la première lettre (bo\underline{njour}, algo\underline{rithme}).
  Si aucune de ses règles ne s'applique, RV est vide (un sigle comme IBN).
  RV n'existe pas dans l'algorithme de la langue anglaise.
  
  \item[R1]
  
  R1 débute après la première consonne précédée d'une voyelle (aim\underline{er}, tap\underline{is}).
  R1 est vide s'il n'y a pas de telle consonne.
  
  \item[R2]
  
  R2 débute après la première consonne précédée d'une voyelle dans R1 (fameus\underline{ement}).
  R2 est vide s'il n'y a pas de telle consonne.
\end{description}

RV peut contenir R1 et inversement.
Les lettres qui ne sont pas dans R1 ni dans RV ne seront pas touchés sauf pour quelques exceptions.

\subsection*{Étape 1: Suffixes standards}

Cette étape sert à trouver la racine des mots, adjectifs, adverbes, etc.

Trouver le suffixe le plus long parmi une liste donnée et faire l'action correspondante.
Voici des exemples de la liste qui compte 43 suffixes et 24 règles.

\begin{itemize}
  \item \textbf{ance iqUe isme able ...}: Supprime si dans R2
  \item \textbf{atrice ateur ation ...}: Supprime si dans R2. Si précédé de \textbf{ic}, supprimer si dans R2, sinon remplacer par \textbf{iqU}
  \item \textbf{logie logies}: Remplace par \textbf{log} si dans R2
  \item \textbf{eaux}: Remplace par \textbf{eau}
  \item \textbf{aux}: Remplace par \textbf{al} si dans R1
  \item \textbf{amment}: Remplacer par \textbf{ant} si dans RV
  \item \textbf{emment}: Remplacer par \textbf{ent} si dans RV
  \item \textbf{ment ments}: Supprimer si dans RV
\end{itemize}

\subsection*{Étape 2: Suffixes de verbes}

Cette étape trouve la racine d'un verbe.
On cherche et enlève les suffixes standards.

Faire cette étape seulement si l'étape 1 n'a rien changé ou si un des suffixes suivants a été trouvé: amment, emment, ment et ments.

\subsubsection*{Étape 2a: Suffixes débutant par i}

Trouver le suffixe le plus long parmi la liste ci-dessous.
S'il est précédé d'une consonne et que le tout est dans RV, supprimer le suffixe excluant la consonne supplémentaire.

îmes, ît, îtes, i, ie, ies, ir, ira, irai, iraIent etc.

\subsubsection*{Étape 2b: Autres suffixes de verbes}

Trouver le suffixe le plus long parmi les trois listes ci-dessous.
Les listes sont non-exaustives afin d'alléger le texte.

\begin{description}
  \item[ions]
  
  Supprimer si dans RV et R2
  
  \item[é ée ées és èrent er era erai eraIent ...]
  
  Supprimer si dans RV
  
  \item[âmes ât âtes a ai aIent ...]
  
  Supprimer si dans RV. Si la lettre e précède le suffixe et qu'elle se trouve aussi dans RV, la supprimer.
\end{description}

\subsection*{Étape 3: Dernière lettre}

Si les étapes 1 ou 2 ont modifié le mot, faire cette étape, sinon passer à l'étape 4.

Si la dernière lettre est un Y, la remplacer par i.
Si c'est un ç, la remplacer par c.

\subsection*{Étape 4: Résidue du suffixe}

Faire cette étape seulement si les étapes 1 à 3 n'ont pas modifié le mot.
Cette étape sert à enlever le pluriel et le féminin des mots très proches de leurs racines.

Si un mot se termine par \textbf{s} et n'est pas précédé de \textbf{a, i, o, u, è ou s}, supprimer ce s final.

Si un mot se termine par \textbf{ion}, que cette finale se trouve dans RV et dans R2 et qu'elle est précédée de la lettre \textbf{s ou t} (cette dernière doit se trouver dans RV), supprimer la finale \textbf{ion}.

Si un mot se termine par \textbf{ier, ière, Ier ou Ière} et que cette finale se trouve dans RV, remplacer cette dernière par \textbf{i}.

Si un mot se termine par \textbf{e} et que cette lettre ce trouve dans RV, la supprimer.

Si un mot se termine par \textbf{ë}, que cette lettre se trouve dans RV et qu'elle est précédée de \textbf{qu}, la supprimer.

\subsection*{Étape 5: Dédoubler la lettre finale}

Les suppressions et remplacements des étapes précédentes peuvent laisser une faute dans la racine du mot.
Cette étape sert à enlever les lettres doubles de certaines finales de mots.

Si un mot se termine par \textbf{enn, onn, ett, ell ou eill}, supprimer la dernière lettre.

\subsection*{Étape 6: Accent final}

Cette étape aussi sert a nettoyer la racine du mot.

Si un mot se termine par la lettre \textbf{è ou é} suivit d'une ou de plusieurs consonnes, enlever l'accent de ce \textbf{e}.

\subsection*{Finalisation}

Finalement, on enlève les majuscules sur les voyelles ajoutées durant l'étape de préparation.

Au final, nous avons la racine du mot.
Lors de la comparaison de texte, il peut y avoir quelques problèmes.
Par exemple les mots acceptables et accepté ont la même racine: accept.
Par contre le sens des 2 mots est différent.

\section{Tests}

Moodle offre deux types de tests: des tests d'acceptations et des tests unitaires.

\subsection{Tests d'acceptations}

Les tests d'acceptations sont exécutés à l'aide de Behat, un \og framwork \fg{} PHP d'automatisation de tests qui se base sur le \og Behavior Driven Developement (BDD) \fg{}.
Les tests sont écrits en anglais, compréhensibles par tous.
Chaque instruction et vérification doit être, préalablement, configurée en PHP.

Un serveur ou une application Selenium exécutera les tests directement dans l'interface d'un navigateur Web.

\begin{lstlisting}[frame=l]
@qtype @qtype_essay
Feature: Test creating an Essay question
  As a teacher
  In order to test my students
  I need to be able to create an Essay question

  Background:
    Given the following "users" exist:
      | username | firstname | lastname | email               |
      | teacher1 | T1        | Teacher1 | teacher1@moodle.com |
    And the following "courses" exist:
      | fullname | shortname | category |
      | Course 1 | C1        | 0        |
    And the following "course enrolments" exist:
      | user     | course | role           |
      | teacher1 | C1     | editingteacher |
    And I log in as "teacher1"
    And I follow "Course 1"
    And I navigate to "Question bank" node in "Course administration"

  Scenario: Create an Essay question with Response format set to 'HTML editor'
    When I add a "Essay" question filling the form with:
      | Question name            | essay-001                      |
      | Question text            | Write an essay with 500 words. |
      | General feedback         | This is general feedback       |
      | Response format          | HTML editor                    |
    Then I should see "essay-001"
\end{lstlisting}

\subsection{Tests unitaires}

Les tests unitaires sont exécutés avec PHP-Unit.

